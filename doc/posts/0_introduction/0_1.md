(0_1_rocos_structure)=
# Rocos模块架构

> 在上一篇内容中，我们已经了解了**小型足球机器人比赛**以及基本的架构。Rocos目标是帮助参赛者轻松构建**核心策略系统**，本文将对Rocos的架构进行介绍。

## SSL软件架构与Rocos

让我们从更细致的角度来看Rocos的模块分布：

```{thumbnail} ../../img/ssl_system.png
```

上图可以粗略拆分成两部分，左侧虚线框内是官方提供的**辅助软件**，一般只会在比赛时运行负责裁判指令以及可视化等功能。**图右侧**展示了Rocos的模块拆分，图中的每个箭头代表了模块间的通信数据流。为了更清晰的展示架构，图中并没有以软件包或进程的方式进行构建，而是以功能模块的方式进行了拆分，箭头所代表的数据流包含了进程的网络通讯、线程间的内存共享等不同方式。
* **Client客户端**： Client作为Rocos系统中的图形界面，同时也是**唯一与Core通讯的模块**，负责处理除了策略外的所有功能，包括与机器人的通讯、裁判指令的接收、图像接收及融合、可视化、调试、LOG回放等功能。
* **Client-grSim仿真**： [grSim](https://github.com/RoboCup-SSL/grSim)是RoboCup小型组官方提供的仿真软件，最初来自于伊朗Parsian战队的开源项目，后被RoboCup小型组官方收编。Client中嵌入了一个精简版的grSim，包含了grSim除界面的所有功能，方便在Client中进行仿真测试。如果做类比，可以在功能上简单理解成 **`grSim ≈ SSL-Vision + Robot`**。
* **Core**： 核心策略模块，无图形界面，由lua和c++共同构成。由上至下可以拆分成**战术Tactic**/**脚本Play**/**任务Task**/**技能Skill**/**规划Plan**五层。
    * **战术Tactic**： 由多个脚本Play以及配套的Task和Skill组成，构成一个宏观的战术风格或打法策略，例如：可以根据不同对手的风格，选择不同的战术进行针对性决策应对。
    * **脚本Play**： 基于Task和Skill构建出多机器人配合策略，每个Play实际是一个**有限状态机（Finite State Machine）**，每个状态是一个任务组定义了每个机器人的具体任务。在比赛中，根据状态机的**状态跳转**可以实现类似于**进攻与防守的转换**。比赛中的**定位球**、**点球**等对裁判指令的响应是通过不同Play间的切换实现的。
    * **任务Task**： 任务是结合辅助策略模块对机器人各种**泛化的Skill的具体封装**。例如：利用`移动`这个`Skill`，配合防守模块的具体计算结果，可以实现对防守阵型中各个角色的任务封装，供Play进行拼装。
    * **技能Skill**： 技能是对机器人的**上层控制**，一般会利用机器人的**底层控制**进行封装，例如：`移动`、`射门`、`传球`、`拦截`等。
    * **规划Plan**： 规划是对机器人的**轨迹规划**，负责将上层`Skill`的目标转化为底层`控制`的目标，例如：`移动`技能的目标是一个点，规划模块负责将这个点转化为机器人的速度和角速度。
* **Controller软件**： Controller是一个单机测试软件，一般独立运行用于**机器人硬件的调试**。可以使用键盘或者手柄控制机器人的运动，同时可以查看机器人的传感器数据、调试机器人的底层控制等。
:::{card} Controller软件界面
:text-align: center
:margin: auto
:width: 50%

```{thumbnail} ../../img/controller.png
```
:::

:::{admonition} 为什么Core不直接与机器人通讯/为什么Core只和Client通信？
:class: hint
* 在编写机器人算法时，我们通常希望代码的重用性变高，因为我们希望弱化`Core`对于仿真和实物机器人的差异，所以我们希望`Core`的代码尽量不涉及到具体的通讯细节而采用**相同的机器人指令协议**。
* 由于`Core`是一个**无图形界面**的软件，所以我们希望图形界面可以**调试**和**可视化**所有信息，机器人指令也作为一个重要信息需要发送给`Client`。
* 由于策略是用户最常更改的模块，也是较为容易出现**崩溃**的模块，我们希望可以解耦策略模块与其他模块，让Client可以为Core做进程守护而维持各个数据流的状态。
:::

:::

